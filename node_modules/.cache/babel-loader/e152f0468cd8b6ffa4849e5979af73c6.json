{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst path = require('path');\n\nlet parsePath = path.parse;\nlet SEP = path.sep ||\n/* istanbul ignore next */\n'/';\nconst origParser = parsePath;\nconst origSep = SEP;\n\nfunction makeRelativeNormalizedPath(str, sep) {\n  const parsed = parsePath(str);\n  let root = parsed.root;\n  let dir;\n  let file = parsed.base;\n  let quoted;\n  let pos; // handle a weird windows case separately\n\n  if (sep === '\\\\') {\n    pos = root.indexOf(':\\\\');\n\n    if (pos >= 0) {\n      root = root.substring(0, pos + 2);\n    }\n  }\n\n  dir = parsed.dir.substring(root.length);\n\n  if (str === '') {\n    return [];\n  }\n\n  if (sep !== '/') {\n    quoted = new RegExp(sep.replace(/\\W/g, '\\\\$&'), 'g');\n    dir = dir.replace(quoted, '/');\n    file = file.replace(quoted, '/'); // excessively paranoid?\n  }\n\n  if (dir !== '') {\n    dir = dir + '/' + file;\n  } else {\n    dir = file;\n  }\n\n  if (dir.substring(0, 1) === '/') {\n    dir = dir.substring(1);\n  }\n\n  dir = dir.split(/\\/+/);\n  return dir;\n}\n\nfunction Path(strOrArray) {\n  if (Array.isArray(strOrArray)) {\n    this.v = strOrArray;\n  } else if (typeof strOrArray === 'string') {\n    this.v = makeRelativeNormalizedPath(strOrArray, SEP);\n  } else {\n    throw new Error('Invalid Path argument must be string or array:' + strOrArray);\n  }\n}\n\nPath.prototype.toString = function () {\n  return this.v.join('/');\n};\n\nPath.prototype.hasParent = function () {\n  return this.v.length > 0;\n};\n\nPath.prototype.parent = function () {\n  if (!this.hasParent()) {\n    throw new Error('Unable to get parent for 0 elem path');\n  }\n\n  const p = this.v.slice();\n  p.pop();\n  return new Path(p);\n};\n\nPath.prototype.elements = function () {\n  return this.v.slice();\n};\n\nPath.prototype.contains = function (other) {\n  let i;\n\n  if (other.length > this.length) {\n    return false;\n  }\n\n  for (i = 0; i < other.length; i += 1) {\n    if (this.v[i] !== other.v[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nPath.prototype.ancestorOf = function (other) {\n  return other.contains(this) && other.length !== this.length;\n};\n\nPath.prototype.descendantOf = function (other) {\n  return this.contains(other) && other.length !== this.length;\n};\n\nPath.prototype.commonPrefixPath = function (other) {\n  const len = this.length > other.length ? other.length : this.length;\n  let i;\n  const ret = [];\n\n  for (i = 0; i < len; i += 1) {\n    if (this.v[i] === other.v[i]) {\n      ret.push(this.v[i]);\n    } else {\n      break;\n    }\n  }\n\n  return new Path(ret);\n};\n\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(f => {\n  Path.prototype[f] = function (...args) {\n    const v = this.v;\n    return v[f](...args);\n  };\n});\n\nPath.compare = function (a, b) {\n  const al = a.length;\n  const bl = b.length;\n\n  if (al < bl) {\n    return -1;\n  }\n\n  if (al > bl) {\n    return 1;\n  }\n\n  const astr = a.toString();\n  const bstr = b.toString();\n  return astr < bstr ? -1 : astr > bstr ? 1 : 0;\n};\n\nObject.defineProperty(Path.prototype, 'length', {\n  enumerable: true,\n\n  get() {\n    return this.v.length;\n  }\n\n});\nmodule.exports = Path;\nPath.tester = {\n  setParserAndSep(p, sep) {\n    parsePath = p;\n    SEP = sep;\n  },\n\n  reset() {\n    parsePath = origParser;\n    SEP = origSep;\n  }\n\n};","map":{"version":3,"sources":["/Users/yanzhao/react-employer-viewer/node_modules/istanbul-lib-report/lib/path.js"],"names":["path","require","parsePath","parse","SEP","sep","origParser","origSep","makeRelativeNormalizedPath","str","parsed","root","dir","file","base","quoted","pos","indexOf","substring","length","RegExp","replace","split","Path","strOrArray","Array","isArray","v","Error","prototype","toString","join","hasParent","parent","p","slice","pop","elements","contains","other","i","ancestorOf","descendantOf","commonPrefixPath","len","ret","push","forEach","f","args","compare","a","b","al","bl","astr","bstr","Object","defineProperty","enumerable","get","module","exports","tester","setParserAndSep","reset"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst path = require('path');\nlet parsePath = path.parse;\nlet SEP = path.sep || /* istanbul ignore next */ '/';\nconst origParser = parsePath;\nconst origSep = SEP;\n\nfunction makeRelativeNormalizedPath(str, sep) {\n    const parsed = parsePath(str);\n    let root = parsed.root;\n    let dir;\n    let file = parsed.base;\n    let quoted;\n    let pos;\n\n    // handle a weird windows case separately\n    if (sep === '\\\\') {\n        pos = root.indexOf(':\\\\');\n        if (pos >= 0) {\n            root = root.substring(0, pos + 2);\n        }\n    }\n    dir = parsed.dir.substring(root.length);\n\n    if (str === '') {\n        return [];\n    }\n\n    if (sep !== '/') {\n        quoted = new RegExp(sep.replace(/\\W/g, '\\\\$&'), 'g');\n        dir = dir.replace(quoted, '/');\n        file = file.replace(quoted, '/'); // excessively paranoid?\n    }\n\n    if (dir !== '') {\n        dir = dir + '/' + file;\n    } else {\n        dir = file;\n    }\n    if (dir.substring(0, 1) === '/') {\n        dir = dir.substring(1);\n    }\n    dir = dir.split(/\\/+/);\n    return dir;\n}\n\nfunction Path(strOrArray) {\n    if (Array.isArray(strOrArray)) {\n        this.v = strOrArray;\n    } else if (typeof strOrArray === 'string') {\n        this.v = makeRelativeNormalizedPath(strOrArray, SEP);\n    } else {\n        throw new Error(\n            'Invalid Path argument must be string or array:' + strOrArray\n        );\n    }\n}\n\nPath.prototype.toString = function() {\n    return this.v.join('/');\n};\n\nPath.prototype.hasParent = function() {\n    return this.v.length > 0;\n};\n\nPath.prototype.parent = function() {\n    if (!this.hasParent()) {\n        throw new Error('Unable to get parent for 0 elem path');\n    }\n    const p = this.v.slice();\n    p.pop();\n    return new Path(p);\n};\n\nPath.prototype.elements = function() {\n    return this.v.slice();\n};\n\nPath.prototype.contains = function(other) {\n    let i;\n    if (other.length > this.length) {\n        return false;\n    }\n    for (i = 0; i < other.length; i += 1) {\n        if (this.v[i] !== other.v[i]) {\n            return false;\n        }\n    }\n    return true;\n};\n\nPath.prototype.ancestorOf = function(other) {\n    return other.contains(this) && other.length !== this.length;\n};\n\nPath.prototype.descendantOf = function(other) {\n    return this.contains(other) && other.length !== this.length;\n};\n\nPath.prototype.commonPrefixPath = function(other) {\n    const len = this.length > other.length ? other.length : this.length;\n    let i;\n    const ret = [];\n\n    for (i = 0; i < len; i += 1) {\n        if (this.v[i] === other.v[i]) {\n            ret.push(this.v[i]);\n        } else {\n            break;\n        }\n    }\n    return new Path(ret);\n};\n\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(f => {\n    Path.prototype[f] = function(...args) {\n        const v = this.v;\n        return v[f](...args);\n    };\n});\n\nPath.compare = function(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    if (al < bl) {\n        return -1;\n    }\n    if (al > bl) {\n        return 1;\n    }\n    const astr = a.toString();\n    const bstr = b.toString();\n    return astr < bstr ? -1 : astr > bstr ? 1 : 0;\n};\n\nObject.defineProperty(Path.prototype, 'length', {\n    enumerable: true,\n    get() {\n        return this.v.length;\n    }\n});\n\nmodule.exports = Path;\nPath.tester = {\n    setParserAndSep(p, sep) {\n        parsePath = p;\n        SEP = sep;\n    },\n    reset() {\n        parsePath = origParser;\n        SEP = origSep;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}
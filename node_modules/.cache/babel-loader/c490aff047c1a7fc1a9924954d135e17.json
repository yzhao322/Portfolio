{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst util = require('util');\n\nconst coverage = require('istanbul-lib-coverage');\n\nconst Path = require('./path');\n\nconst tree = require('./tree');\n\nconst BaseNode = tree.Node;\nconst BaseTree = tree.Tree;\n\nfunction ReportNode(path, fileCoverage) {\n  this.path = path;\n  this.parent = null;\n  this.fileCoverage = fileCoverage;\n  this.children = [];\n}\n\nutil.inherits(ReportNode, BaseNode);\n\nReportNode.prototype.addChild = function (child) {\n  child.parent = this;\n  this.children.push(child);\n};\n\nReportNode.prototype.asRelative = function (p) {\n  /* istanbul ignore if */\n  if (p.substring(0, 1) === '/') {\n    return p.substring(1);\n  }\n\n  return p;\n};\n\nReportNode.prototype.getQualifiedName = function () {\n  return this.asRelative(this.path.toString());\n};\n\nReportNode.prototype.getRelativeName = function () {\n  const parent = this.getParent();\n  const myPath = this.path;\n  let relPath;\n  let i;\n  const parentPath = parent ? parent.path : new Path([]);\n\n  if (parentPath.ancestorOf(myPath)) {\n    relPath = new Path(myPath.elements());\n\n    for (i = 0; i < parentPath.length; i += 1) {\n      relPath.shift();\n    }\n\n    return this.asRelative(relPath.toString());\n  }\n\n  return this.asRelative(this.path.toString());\n};\n\nReportNode.prototype.getParent = function () {\n  return this.parent;\n};\n\nReportNode.prototype.getChildren = function () {\n  return this.children;\n};\n\nReportNode.prototype.isSummary = function () {\n  return !this.fileCoverage;\n};\n\nReportNode.prototype.getFileCoverage = function () {\n  return this.fileCoverage;\n};\n\nReportNode.prototype.getCoverageSummary = function (filesOnly) {\n  const cacheProp = 'c_' + (filesOnly ? 'files' : 'full');\n  let summary;\n\n  if (this.hasOwnProperty(cacheProp)) {\n    return this[cacheProp];\n  }\n\n  if (!this.isSummary()) {\n    summary = this.getFileCoverage().toSummary();\n  } else {\n    let count = 0;\n    summary = coverage.createCoverageSummary();\n    this.getChildren().forEach(child => {\n      if (filesOnly && child.isSummary()) {\n        return;\n      }\n\n      count += 1;\n      summary.merge(child.getCoverageSummary(filesOnly));\n    });\n\n    if (count === 0 && filesOnly) {\n      summary = null;\n    }\n  }\n\n  this[cacheProp] = summary;\n  return summary;\n};\n\nfunction treeFor(root, childPrefix) {\n  const tree = new BaseTree();\n\n  const maybePrefix = function (node) {\n    if (childPrefix && !node.isRoot()) {\n      node.path.unshift(childPrefix);\n    }\n  };\n\n  tree.getRoot = function () {\n    return root;\n  };\n\n  const visitor = {\n    onDetail(node) {\n      maybePrefix(node);\n    },\n\n    onSummary(node) {\n      maybePrefix(node);\n      node.children.sort((a, b) => {\n        const astr = a.path.toString();\n        const bstr = b.path.toString();\n        return astr < bstr ? -1 : astr > bstr ? 1 :\n        /* istanbul ignore next */\n        0;\n      });\n    }\n\n  };\n  tree.visit(visitor);\n  return tree;\n}\n\nfunction findCommonParent(paths) {\n  if (paths.length === 0) {\n    return new Path([]);\n  }\n\n  let common = paths[0];\n  let i;\n\n  for (i = 1; i < paths.length; i += 1) {\n    common = common.commonPrefixPath(paths[i]);\n\n    if (common.length === 0) {\n      break;\n    }\n  }\n\n  return common;\n}\n\nfunction toInitialList(coverageMap) {\n  const ret = [];\n  coverageMap.files().forEach(filePath => {\n    const p = new Path(filePath);\n    const coverage = coverageMap.fileCoverageFor(filePath);\n    ret.push({\n      filePath,\n      path: p,\n      fileCoverage: coverage\n    });\n  });\n  const commonParent = findCommonParent(ret.map(o => o.path.parent()));\n\n  if (commonParent.length > 0) {\n    ret.forEach(o => {\n      o.path.splice(0, commonParent.length);\n    });\n  }\n\n  return {\n    list: ret,\n    commonParent\n  };\n}\n\nfunction toDirParents(list) {\n  const nodeMap = Object.create(null);\n  const parentNodeList = [];\n  list.forEach(o => {\n    const node = new ReportNode(o.path, o.fileCoverage);\n    const parentPath = o.path.parent();\n    let parent = nodeMap[parentPath.toString()];\n\n    if (!parent) {\n      parent = new ReportNode(parentPath);\n      nodeMap[parentPath.toString()] = parent;\n      parentNodeList.push(parent);\n    }\n\n    parent.addChild(node);\n  });\n  return parentNodeList;\n}\n\nfunction foldIntoParents(nodeList) {\n  const ret = [];\n  let i;\n  let j; // sort by longest length first\n\n  nodeList.sort((a, b) => -1 * Path.compare(a.path, b.path));\n\n  for (i = 0; i < nodeList.length; i += 1) {\n    const first = nodeList[i];\n    let inserted = false;\n\n    for (j = i + 1; j < nodeList.length; j += 1) {\n      const second = nodeList[j];\n\n      if (second.path.ancestorOf(first.path)) {\n        second.addChild(first);\n        inserted = true;\n        break;\n      }\n    }\n\n    if (!inserted) {\n      ret.push(first);\n    }\n  }\n\n  return ret;\n}\n\nfunction createRoot() {\n  return new ReportNode(new Path([]));\n}\n\nfunction createNestedSummary(coverageMap) {\n  const flattened = toInitialList(coverageMap);\n  const dirParents = toDirParents(flattened.list);\n  const topNodes = foldIntoParents(dirParents);\n\n  if (topNodes.length === 0) {\n    return treeFor(new ReportNode(new Path([])));\n  }\n\n  if (topNodes.length === 1) {\n    return treeFor(topNodes[0]);\n  }\n\n  const root = createRoot();\n  topNodes.forEach(node => {\n    root.addChild(node);\n  });\n  return treeFor(root);\n}\n\nfunction createPackageSummary(coverageMap) {\n  const flattened = toInitialList(coverageMap);\n  const dirParents = toDirParents(flattened.list);\n  const common = flattened.commonParent;\n  let prefix;\n  let root;\n\n  if (dirParents.length === 1) {\n    root = dirParents[0];\n  } else {\n    root = createRoot(); // if one of the dirs is itself the root,\n    // then we need to create a top-level dir\n\n    dirParents.forEach(dp => {\n      if (dp.path.length === 0) {\n        prefix = 'root';\n      }\n    });\n\n    if (prefix && common.length > 0) {\n      prefix = common.elements()[common.elements().length - 1];\n    }\n\n    dirParents.forEach(node => {\n      root.addChild(node);\n    });\n  }\n\n  return treeFor(root, prefix);\n}\n\nfunction createFlatSummary(coverageMap) {\n  const flattened = toInitialList(coverageMap);\n  const list = flattened.list;\n  const root = createRoot();\n  list.forEach(o => {\n    const node = new ReportNode(o.path, o.fileCoverage);\n    root.addChild(node);\n  });\n  return treeFor(root);\n}\n\nmodule.exports = {\n  createNestedSummary,\n  createPackageSummary,\n  createFlatSummary\n};","map":{"version":3,"sources":["/Users/yanzhao/react-employer-viewer/node_modules/istanbul-lib-report/lib/summarizer.js"],"names":["util","require","coverage","Path","tree","BaseNode","Node","BaseTree","Tree","ReportNode","path","fileCoverage","parent","children","inherits","prototype","addChild","child","push","asRelative","p","substring","getQualifiedName","toString","getRelativeName","getParent","myPath","relPath","i","parentPath","ancestorOf","elements","length","shift","getChildren","isSummary","getFileCoverage","getCoverageSummary","filesOnly","cacheProp","summary","hasOwnProperty","toSummary","count","createCoverageSummary","forEach","merge","treeFor","root","childPrefix","maybePrefix","node","isRoot","unshift","getRoot","visitor","onDetail","onSummary","sort","a","b","astr","bstr","visit","findCommonParent","paths","common","commonPrefixPath","toInitialList","coverageMap","ret","files","filePath","fileCoverageFor","commonParent","map","o","splice","list","toDirParents","nodeMap","Object","create","parentNodeList","foldIntoParents","nodeList","j","compare","first","inserted","second","createRoot","createNestedSummary","flattened","dirParents","topNodes","createPackageSummary","prefix","dp","createFlatSummary","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst util = require('util');\nconst coverage = require('istanbul-lib-coverage');\nconst Path = require('./path');\nconst tree = require('./tree');\nconst BaseNode = tree.Node;\nconst BaseTree = tree.Tree;\n\nfunction ReportNode(path, fileCoverage) {\n    this.path = path;\n    this.parent = null;\n    this.fileCoverage = fileCoverage;\n    this.children = [];\n}\n\nutil.inherits(ReportNode, BaseNode);\n\nReportNode.prototype.addChild = function(child) {\n    child.parent = this;\n    this.children.push(child);\n};\n\nReportNode.prototype.asRelative = function(p) {\n    /* istanbul ignore if */\n    if (p.substring(0, 1) === '/') {\n        return p.substring(1);\n    }\n    return p;\n};\n\nReportNode.prototype.getQualifiedName = function() {\n    return this.asRelative(this.path.toString());\n};\n\nReportNode.prototype.getRelativeName = function() {\n    const parent = this.getParent();\n    const myPath = this.path;\n    let relPath;\n    let i;\n    const parentPath = parent ? parent.path : new Path([]);\n    if (parentPath.ancestorOf(myPath)) {\n        relPath = new Path(myPath.elements());\n        for (i = 0; i < parentPath.length; i += 1) {\n            relPath.shift();\n        }\n        return this.asRelative(relPath.toString());\n    }\n    return this.asRelative(this.path.toString());\n};\n\nReportNode.prototype.getParent = function() {\n    return this.parent;\n};\n\nReportNode.prototype.getChildren = function() {\n    return this.children;\n};\n\nReportNode.prototype.isSummary = function() {\n    return !this.fileCoverage;\n};\n\nReportNode.prototype.getFileCoverage = function() {\n    return this.fileCoverage;\n};\n\nReportNode.prototype.getCoverageSummary = function(filesOnly) {\n    const cacheProp = 'c_' + (filesOnly ? 'files' : 'full');\n    let summary;\n\n    if (this.hasOwnProperty(cacheProp)) {\n        return this[cacheProp];\n    }\n\n    if (!this.isSummary()) {\n        summary = this.getFileCoverage().toSummary();\n    } else {\n        let count = 0;\n        summary = coverage.createCoverageSummary();\n        this.getChildren().forEach(child => {\n            if (filesOnly && child.isSummary()) {\n                return;\n            }\n            count += 1;\n            summary.merge(child.getCoverageSummary(filesOnly));\n        });\n        if (count === 0 && filesOnly) {\n            summary = null;\n        }\n    }\n    this[cacheProp] = summary;\n    return summary;\n};\n\nfunction treeFor(root, childPrefix) {\n    const tree = new BaseTree();\n    const maybePrefix = function(node) {\n        if (childPrefix && !node.isRoot()) {\n            node.path.unshift(childPrefix);\n        }\n    };\n    tree.getRoot = function() {\n        return root;\n    };\n    const visitor = {\n        onDetail(node) {\n            maybePrefix(node);\n        },\n        onSummary(node) {\n            maybePrefix(node);\n            node.children.sort((a, b) => {\n                const astr = a.path.toString();\n                const bstr = b.path.toString();\n                return astr < bstr\n                    ? -1\n                    : astr > bstr\n                    ? 1\n                    : /* istanbul ignore next */ 0;\n            });\n        }\n    };\n    tree.visit(visitor);\n    return tree;\n}\n\nfunction findCommonParent(paths) {\n    if (paths.length === 0) {\n        return new Path([]);\n    }\n    let common = paths[0];\n    let i;\n\n    for (i = 1; i < paths.length; i += 1) {\n        common = common.commonPrefixPath(paths[i]);\n        if (common.length === 0) {\n            break;\n        }\n    }\n    return common;\n}\n\nfunction toInitialList(coverageMap) {\n    const ret = [];\n    coverageMap.files().forEach(filePath => {\n        const p = new Path(filePath);\n        const coverage = coverageMap.fileCoverageFor(filePath);\n        ret.push({\n            filePath,\n            path: p,\n            fileCoverage: coverage\n        });\n    });\n\n    const commonParent = findCommonParent(ret.map(o => o.path.parent()));\n    if (commonParent.length > 0) {\n        ret.forEach(o => {\n            o.path.splice(0, commonParent.length);\n        });\n    }\n    return {\n        list: ret,\n        commonParent\n    };\n}\n\nfunction toDirParents(list) {\n    const nodeMap = Object.create(null);\n    const parentNodeList = [];\n    list.forEach(o => {\n        const node = new ReportNode(o.path, o.fileCoverage);\n        const parentPath = o.path.parent();\n        let parent = nodeMap[parentPath.toString()];\n\n        if (!parent) {\n            parent = new ReportNode(parentPath);\n            nodeMap[parentPath.toString()] = parent;\n            parentNodeList.push(parent);\n        }\n        parent.addChild(node);\n    });\n    return parentNodeList;\n}\n\nfunction foldIntoParents(nodeList) {\n    const ret = [];\n    let i;\n    let j;\n\n    // sort by longest length first\n    nodeList.sort((a, b) => -1 * Path.compare(a.path, b.path));\n\n    for (i = 0; i < nodeList.length; i += 1) {\n        const first = nodeList[i];\n        let inserted = false;\n\n        for (j = i + 1; j < nodeList.length; j += 1) {\n            const second = nodeList[j];\n            if (second.path.ancestorOf(first.path)) {\n                second.addChild(first);\n                inserted = true;\n                break;\n            }\n        }\n\n        if (!inserted) {\n            ret.push(first);\n        }\n    }\n    return ret;\n}\n\nfunction createRoot() {\n    return new ReportNode(new Path([]));\n}\n\nfunction createNestedSummary(coverageMap) {\n    const flattened = toInitialList(coverageMap);\n    const dirParents = toDirParents(flattened.list);\n    const topNodes = foldIntoParents(dirParents);\n\n    if (topNodes.length === 0) {\n        return treeFor(new ReportNode(new Path([])));\n    }\n\n    if (topNodes.length === 1) {\n        return treeFor(topNodes[0]);\n    }\n\n    const root = createRoot();\n    topNodes.forEach(node => {\n        root.addChild(node);\n    });\n    return treeFor(root);\n}\n\nfunction createPackageSummary(coverageMap) {\n    const flattened = toInitialList(coverageMap);\n    const dirParents = toDirParents(flattened.list);\n    const common = flattened.commonParent;\n    let prefix;\n    let root;\n\n    if (dirParents.length === 1) {\n        root = dirParents[0];\n    } else {\n        root = createRoot();\n        // if one of the dirs is itself the root,\n        // then we need to create a top-level dir\n        dirParents.forEach(dp => {\n            if (dp.path.length === 0) {\n                prefix = 'root';\n            }\n        });\n        if (prefix && common.length > 0) {\n            prefix = common.elements()[common.elements().length - 1];\n        }\n        dirParents.forEach(node => {\n            root.addChild(node);\n        });\n    }\n    return treeFor(root, prefix);\n}\n\nfunction createFlatSummary(coverageMap) {\n    const flattened = toInitialList(coverageMap);\n    const list = flattened.list;\n    const root = createRoot();\n\n    list.forEach(o => {\n        const node = new ReportNode(o.path, o.fileCoverage);\n        root.addChild(node);\n    });\n    return treeFor(root);\n}\n\nmodule.exports = {\n    createNestedSummary,\n    createPackageSummary,\n    createFlatSummary\n};\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst fs = require('fs');\n\nconst FileWriter = require('./file-writer');\n\nconst XMLWriter = require('./xml-writer');\n\nconst tree = require('./tree');\n\nconst watermarks = require('./watermarks');\n\nfunction defaultSourceLookup(path) {\n  try {\n    return fs.readFileSync(path, 'utf8');\n  } catch (ex) {\n    throw new Error('Unable to lookup source: ' + path + '(' + ex.message + ')');\n  }\n}\n\nfunction mergeWatermarks(specified, defaults) {\n  specified = specified || {};\n  Object.keys(defaults).forEach(k => {\n    const specValue = specified[k];\n\n    if (!(specValue && Array.isArray(specValue) && specValue.length === 2)) {\n      specified[k] = defaults[k];\n    }\n  });\n  return specified;\n}\n/**\n * A reporting context that is passed to report implementations\n * @param {Object} [opts=null] opts options\n * @param {String} [opts.dir='coverage'] opts.dir the reporting directory\n * @param {Object} [opts.watermarks=null] opts.watermarks watermarks for\n *  statements, lines, branches and functions\n * @param {Function} [opts.sourceFinder=fsLookup] opts.sourceFinder a\n *  function that returns source code given a file path. Defaults to\n *  filesystem lookups based on path.\n * @constructor\n */\n\n\nfunction Context(opts) {\n  opts = opts || {};\n  this.dir = opts.dir || 'coverage';\n  this.watermarks = mergeWatermarks(opts.watermarks, watermarks.getDefault());\n  this.sourceFinder = opts.sourceFinder || defaultSourceLookup;\n  this.data = {};\n}\n\nObject.defineProperty(Context.prototype, 'writer', {\n  enumerable: true,\n\n  get() {\n    if (!this.data.writer) {\n      this.data.writer = new FileWriter(this.dir);\n    }\n\n    return this.data.writer;\n  }\n\n});\n/**\n * returns a FileWriter implementation for reporting use. Also available\n * as the `writer` property on the context.\n * @returns {Writer}\n */\n\nContext.prototype.getWriter = function () {\n  return this.writer;\n};\n/**\n * returns the source code for the specified file path or throws if\n * the source could not be found.\n * @param {String} filePath the file path as found in a file coverage object\n * @returns {String} the source code\n */\n\n\nContext.prototype.getSource = function (filePath) {\n  return this.sourceFinder(filePath);\n};\n/**\n * returns the coverage class given a coverage\n * types and a percentage value.\n * @param {String} type - the coverage type, one of `statements`, `functions`,\n *  `branches`, or `lines`\n * @param {Number} value - the percentage value\n * @returns {String} one of `high`, `medium` or `low`\n */\n\n\nContext.prototype.classForPercent = function (type, value) {\n  const watermarks = this.watermarks[type];\n\n  if (!watermarks) {\n    return 'unknown';\n  }\n\n  if (value < watermarks[0]) {\n    return 'low';\n  }\n\n  if (value >= watermarks[1]) {\n    return 'high';\n  }\n\n  return 'medium';\n};\n/**\n * returns an XML writer for the supplied content writer\n * @param {ContentWriter} contentWriter the content writer to which the returned XML writer\n *  writes data\n * @returns {XMLWriter}\n */\n\n\nContext.prototype.getXMLWriter = function (contentWriter) {\n  return new XMLWriter(contentWriter);\n};\n/**\n * returns a full visitor given a partial one.\n * @param {Object} partialVisitor a partial visitor only having the functions of\n *  interest to the caller. These functions are called with a scope that is the\n *  supplied object.\n * @returns {Visitor}\n */\n\n\nContext.prototype.getVisitor = function (partialVisitor) {\n  return new tree.Visitor(partialVisitor);\n};\n\nmodule.exports = {\n  create(opts) {\n    return new Context(opts);\n  }\n\n};","map":{"version":3,"sources":["/Users/yanzhao/react-employer-viewer/node_modules/istanbul-lib-report/lib/context.js"],"names":["fs","require","FileWriter","XMLWriter","tree","watermarks","defaultSourceLookup","path","readFileSync","ex","Error","message","mergeWatermarks","specified","defaults","Object","keys","forEach","k","specValue","Array","isArray","length","Context","opts","dir","getDefault","sourceFinder","data","defineProperty","prototype","enumerable","get","writer","getWriter","getSource","filePath","classForPercent","type","value","getXMLWriter","contentWriter","getVisitor","partialVisitor","Visitor","module","exports","create"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst fs = require('fs');\nconst FileWriter = require('./file-writer');\nconst XMLWriter = require('./xml-writer');\nconst tree = require('./tree');\nconst watermarks = require('./watermarks');\n\nfunction defaultSourceLookup(path) {\n    try {\n        return fs.readFileSync(path, 'utf8');\n    } catch (ex) {\n        throw new Error(\n            'Unable to lookup source: ' + path + '(' + ex.message + ')'\n        );\n    }\n}\n\nfunction mergeWatermarks(specified, defaults) {\n    specified = specified || {};\n    Object.keys(defaults).forEach(k => {\n        const specValue = specified[k];\n        if (\n            !(specValue && Array.isArray(specValue) && specValue.length === 2)\n        ) {\n            specified[k] = defaults[k];\n        }\n    });\n    return specified;\n}\n/**\n * A reporting context that is passed to report implementations\n * @param {Object} [opts=null] opts options\n * @param {String} [opts.dir='coverage'] opts.dir the reporting directory\n * @param {Object} [opts.watermarks=null] opts.watermarks watermarks for\n *  statements, lines, branches and functions\n * @param {Function} [opts.sourceFinder=fsLookup] opts.sourceFinder a\n *  function that returns source code given a file path. Defaults to\n *  filesystem lookups based on path.\n * @constructor\n */\nfunction Context(opts) {\n    opts = opts || {};\n    this.dir = opts.dir || 'coverage';\n    this.watermarks = mergeWatermarks(opts.watermarks, watermarks.getDefault());\n    this.sourceFinder = opts.sourceFinder || defaultSourceLookup;\n    this.data = {};\n}\n\nObject.defineProperty(Context.prototype, 'writer', {\n    enumerable: true,\n    get() {\n        if (!this.data.writer) {\n            this.data.writer = new FileWriter(this.dir);\n        }\n        return this.data.writer;\n    }\n});\n\n/**\n * returns a FileWriter implementation for reporting use. Also available\n * as the `writer` property on the context.\n * @returns {Writer}\n */\nContext.prototype.getWriter = function() {\n    return this.writer;\n};\n\n/**\n * returns the source code for the specified file path or throws if\n * the source could not be found.\n * @param {String} filePath the file path as found in a file coverage object\n * @returns {String} the source code\n */\nContext.prototype.getSource = function(filePath) {\n    return this.sourceFinder(filePath);\n};\n\n/**\n * returns the coverage class given a coverage\n * types and a percentage value.\n * @param {String} type - the coverage type, one of `statements`, `functions`,\n *  `branches`, or `lines`\n * @param {Number} value - the percentage value\n * @returns {String} one of `high`, `medium` or `low`\n */\nContext.prototype.classForPercent = function(type, value) {\n    const watermarks = this.watermarks[type];\n    if (!watermarks) {\n        return 'unknown';\n    }\n    if (value < watermarks[0]) {\n        return 'low';\n    }\n    if (value >= watermarks[1]) {\n        return 'high';\n    }\n    return 'medium';\n};\n/**\n * returns an XML writer for the supplied content writer\n * @param {ContentWriter} contentWriter the content writer to which the returned XML writer\n *  writes data\n * @returns {XMLWriter}\n */\nContext.prototype.getXMLWriter = function(contentWriter) {\n    return new XMLWriter(contentWriter);\n};\n/**\n * returns a full visitor given a partial one.\n * @param {Object} partialVisitor a partial visitor only having the functions of\n *  interest to the caller. These functions are called with a scope that is the\n *  supplied object.\n * @returns {Visitor}\n */\nContext.prototype.getVisitor = function(partialVisitor) {\n    return new tree.Visitor(partialVisitor);\n};\n\nmodule.exports = {\n    create(opts) {\n        return new Context(opts);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst util = require('util');\n/**\n * An object with methods that are called during the traversal of the coverage tree.\n * A visitor has the following methods that are called during tree traversal.\n *\n *   * `onStart(root, state)` - called before traversal begins\n *   * `onSummary(node, state)` - called for every summary node\n *   * `onDetail(node, state)` - called for every detail node\n *   * `onSummaryEnd(node, state)` - called after all children have been visited for\n *      a summary node.\n *   * `onEnd(root, state)` - called after traversal ends\n *\n * @param delegate - a partial visitor that only implements the methods of interest\n *  The visitor object supplies the missing methods as noops. For example, reports\n *  that only need the final coverage summary need implement `onStart` and nothing\n *  else. Reports that use only detailed coverage information need implement `onDetail`\n *  and nothing else.\n * @constructor\n */\n\n\nfunction Visitor(delegate) {\n  this.delegate = delegate;\n}\n\n['Start', 'End', 'Summary', 'SummaryEnd', 'Detail'].forEach(k => {\n  const f = 'on' + k;\n\n  Visitor.prototype[f] = function (node, state) {\n    if (this.delegate[f] && typeof this.delegate[f] === 'function') {\n      this.delegate[f].call(this.delegate, node, state);\n    }\n  };\n});\n\nfunction CompositeVisitor(visitors) {\n  if (!Array.isArray(visitors)) {\n    visitors = [visitors];\n  }\n\n  this.visitors = visitors.map(v => {\n    if (v instanceof Visitor) {\n      return v;\n    }\n\n    return new Visitor(v);\n  });\n}\n\nutil.inherits(CompositeVisitor, Visitor);\n['Start', 'Summary', 'SummaryEnd', 'Detail', 'End'].forEach(k => {\n  const f = 'on' + k;\n\n  CompositeVisitor.prototype[f] = function (node, state) {\n    this.visitors.forEach(v => {\n      v[f](node, state);\n    });\n  };\n});\n\nfunction Node() {}\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getQualifiedName = function () {\n  throw new Error('getQualifiedName must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getRelativeName = function () {\n  throw new Error('getRelativeName must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.isRoot = function () {\n  return !this.getParent();\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getParent = function () {\n  throw new Error('getParent must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getChildren = function () {\n  throw new Error('getChildren must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.isSummary = function () {\n  throw new Error('isSummary must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getCoverageSummary = function ()\n/* filesOnly */\n{\n  throw new Error('getCoverageSummary must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getFileCoverage = function () {\n  throw new Error('getFileCoverage must be overridden');\n};\n/**\n * visit all nodes depth-first from this node down. Note that `onStart`\n * and `onEnd` are never called on the visitor even if the current\n * node is the root of the tree.\n * @param visitor a full visitor that is called during tree traversal\n * @param state optional state that is passed around\n */\n\n\nNode.prototype.visit = function (visitor, state) {\n  if (this.isSummary()) {\n    visitor.onSummary(this, state);\n  } else {\n    visitor.onDetail(this, state);\n  }\n\n  this.getChildren().forEach(child => {\n    child.visit(visitor, state);\n  });\n\n  if (this.isSummary()) {\n    visitor.onSummaryEnd(this, state);\n  }\n};\n/**\n * abstract base class for a coverage tree.\n * @constructor\n */\n\n\nfunction Tree() {}\n/**\n * returns the root node of the tree\n */\n\n/* istanbul ignore next: abstract method */\n\n\nTree.prototype.getRoot = function () {\n  throw new Error('getRoot must be overridden');\n};\n/**\n * visits the tree depth-first with the supplied partial visitor\n * @param visitor - a potentially partial visitor\n * @param state - the state to be passed around during tree traversal\n */\n\n\nTree.prototype.visit = function (visitor, state) {\n  if (!(visitor instanceof Visitor)) {\n    visitor = new Visitor(visitor);\n  }\n\n  visitor.onStart(this.getRoot(), state);\n  this.getRoot().visit(visitor, state);\n  visitor.onEnd(this.getRoot(), state);\n};\n\nmodule.exports = {\n  Tree,\n  Node,\n  Visitor,\n  CompositeVisitor\n};","map":{"version":3,"sources":["/Users/yanzhao/react-employer-viewer/node_modules/istanbul-lib-report/lib/tree.js"],"names":["util","require","Visitor","delegate","forEach","k","f","prototype","node","state","call","CompositeVisitor","visitors","Array","isArray","map","v","inherits","Node","getQualifiedName","Error","getRelativeName","isRoot","getParent","getChildren","isSummary","getCoverageSummary","getFileCoverage","visit","visitor","onSummary","onDetail","child","onSummaryEnd","Tree","getRoot","onStart","onEnd","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst util = require('util');\n/**\n * An object with methods that are called during the traversal of the coverage tree.\n * A visitor has the following methods that are called during tree traversal.\n *\n *   * `onStart(root, state)` - called before traversal begins\n *   * `onSummary(node, state)` - called for every summary node\n *   * `onDetail(node, state)` - called for every detail node\n *   * `onSummaryEnd(node, state)` - called after all children have been visited for\n *      a summary node.\n *   * `onEnd(root, state)` - called after traversal ends\n *\n * @param delegate - a partial visitor that only implements the methods of interest\n *  The visitor object supplies the missing methods as noops. For example, reports\n *  that only need the final coverage summary need implement `onStart` and nothing\n *  else. Reports that use only detailed coverage information need implement `onDetail`\n *  and nothing else.\n * @constructor\n */\nfunction Visitor(delegate) {\n    this.delegate = delegate;\n}\n\n['Start', 'End', 'Summary', 'SummaryEnd', 'Detail'].forEach(k => {\n    const f = 'on' + k;\n    Visitor.prototype[f] = function(node, state) {\n        if (this.delegate[f] && typeof this.delegate[f] === 'function') {\n            this.delegate[f].call(this.delegate, node, state);\n        }\n    };\n});\n\nfunction CompositeVisitor(visitors) {\n    if (!Array.isArray(visitors)) {\n        visitors = [visitors];\n    }\n    this.visitors = visitors.map(v => {\n        if (v instanceof Visitor) {\n            return v;\n        }\n        return new Visitor(v);\n    });\n}\n\nutil.inherits(CompositeVisitor, Visitor);\n\n['Start', 'Summary', 'SummaryEnd', 'Detail', 'End'].forEach(k => {\n    const f = 'on' + k;\n    CompositeVisitor.prototype[f] = function(node, state) {\n        this.visitors.forEach(v => {\n            v[f](node, state);\n        });\n    };\n});\n\nfunction Node() {}\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getQualifiedName = function() {\n    throw new Error('getQualifiedName must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getRelativeName = function() {\n    throw new Error('getRelativeName must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.isRoot = function() {\n    return !this.getParent();\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getParent = function() {\n    throw new Error('getParent must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getChildren = function() {\n    throw new Error('getChildren must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.isSummary = function() {\n    throw new Error('isSummary must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getCoverageSummary = function(/* filesOnly */) {\n    throw new Error('getCoverageSummary must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getFileCoverage = function() {\n    throw new Error('getFileCoverage must be overridden');\n};\n/**\n * visit all nodes depth-first from this node down. Note that `onStart`\n * and `onEnd` are never called on the visitor even if the current\n * node is the root of the tree.\n * @param visitor a full visitor that is called during tree traversal\n * @param state optional state that is passed around\n */\nNode.prototype.visit = function(visitor, state) {\n    if (this.isSummary()) {\n        visitor.onSummary(this, state);\n    } else {\n        visitor.onDetail(this, state);\n    }\n\n    this.getChildren().forEach(child => {\n        child.visit(visitor, state);\n    });\n\n    if (this.isSummary()) {\n        visitor.onSummaryEnd(this, state);\n    }\n};\n\n/**\n * abstract base class for a coverage tree.\n * @constructor\n */\nfunction Tree() {}\n\n/**\n * returns the root node of the tree\n */\n/* istanbul ignore next: abstract method */\nTree.prototype.getRoot = function() {\n    throw new Error('getRoot must be overridden');\n};\n\n/**\n * visits the tree depth-first with the supplied partial visitor\n * @param visitor - a potentially partial visitor\n * @param state - the state to be passed around during tree traversal\n */\nTree.prototype.visit = function(visitor, state) {\n    if (!(visitor instanceof Visitor)) {\n        visitor = new Visitor(visitor);\n    }\n    visitor.onStart(this.getRoot(), state);\n    this.getRoot().visit(visitor, state);\n    visitor.onEnd(this.getRoot(), state);\n};\n\nmodule.exports = {\n    Tree,\n    Node,\n    Visitor,\n    CompositeVisitor\n};\n"]},"metadata":{},"sourceType":"script"}